using System.Collections.Immutable;

namespace Charon.Analyzer;

[Generator(LanguageNames.CSharp)]
public sealed class DumpGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                 static (node, _) => true,
                 static (ctx, _) => ctx.Node
            )
            .Where(m => m is not null);

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation, Execute);
    }

    private static void Execute(SourceProductionContext context, (Compilation Left, ImmutableArray<SyntaxNode> Right) tuple)
    {
        var (compilation, list) = tuple;
        var lines = new List<string>
        {
            "Options:",
            $"  Language: {compilation.Options.Language}",
            $"  Optimization level: {compilation.Options.OptimizationLevel}",
            $"  Platform: {compilation.Options.Platform}",
            $"  Output kind: {compilation.Options.OutputKind}"
        };

        var syntaxTrees = compilation.SyntaxTrees;

        lines.Add("Syntax trees:");

        foreach (SyntaxTree tree in syntaxTrees)
        {
            lines.Add($"  File path: {tree.FilePath}");
        }

        lines.Add("Classes:");

        foreach (var syntax in list)
        {
            // var symbol = compilation.GetSemanticModel(syntax.SyntaxTree).GetDeclaredSymbol(syntax) as INamedTypeSymbol;

            // items.Add($"\"  {symbol?.ToDisplayString()}\"");

            lines.Add($"  {syntax.GetType().FullName} => {syntax}");
        }

        var theCode = $$"""
// <auto-generated />
namespace Charon.Dumps;

public static class Dump
{
/*
{{string.Join("\n", lines)}}
*/
}
""";

        context.AddSource("Dump.g.cs", theCode);
    }
}
